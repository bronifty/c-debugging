# Move Constructors

## && Reference 
```ts
// Generic (like C++ template) - type T is a variable
function foo<T>(x: T) { ... }

// Fixed type (like C++ static type) - string is not a variable
function bar(x: string) { ... }
```

```cpp
// Template - T is a variable, && binds to type-variable first
template<typename T>
void foo(T&& x) { ... }

// Fixed type - Person is not a variable, && can only bind to data
void bar(Person&& x) { ... }
```

- The key insight:
When the type is a variable (template/generic), && binds to that type-variable
When the type is fixed (primitive/static), && can only bind to the data
So yes, we could think of fixed types as "primitives" in the sense that they're not variable - they're predefined and immutable at the type level, just like JavaScript's primitive types. The reference (&&) always seeks a variable to bind to, whether that's a type-variable or a data-variable.

## Pointers 

```cpp
int* ptr = new int(5);


// Memory layout:
// ptr         -> [Address1]  // ptr is a memory location storing Address2
// Address1    -> [Address2]  // value stored in ptr (points to the int)
// Address2    -> [5]        // value that ptr points to (*ptr)

&ptr    // gives Address1 (ptr's own location)
ptr     // gives Address2 (location of the int)
*ptr    // gives 5 (value at Address2)
```

## Move Assignment Operator

```cpp 
Person &operator=(Person &&other)
//  ^                    ^
//  returns lvalue ref   takes rvalue ref parameter
{
    // ... operations ...
    return *this;  // *this is an lvalue
}
```

About *this:
this is a pointer to the current object
*this is a dereferenced pointer that gives us the actual object
*this is an lvalue because it refers to the persistent object in memory
We return a reference to this lvalue (Person&)
The return value:

```cpp 
Person &operator=  // Returns lvalue reference
return *this;      // Returns reference to lvalue object
```

```cpp
// Example:
Person a, b;
a = std::move(b);  // b is converted to rvalue                   
// operation returns reference to a (lvalue)
```

The reason *this must be an lvalue is because it refers to the persistent object that continues to exist after the operation. It's not temporary data (rvalue) - it's the actual object in memory that we want to keep using.

### LLM Q&A
1. Q: in C++ when std::move(Person&&) is called, that is a function implemented by the Person class, and specifically in the move assignement operator Person &operator=(Person &&other) {...}?
1. A: Not exactly. Let me clarify:
std::move() is a standard library function, not a member of the Person class
```cpp 
   // std::move just casts its argument to an rvalue reference
   std::move(andy);  // Converts andy to Person&&
```
When you do:
```cpp 
   Person andy1;
   andy1 = std::move(andy);  // Two steps happen:
```
What actually happens is:
First, std::move(andy) converts andy to an rvalue reference (Person&&)
Then, Person::operator=(Person&&) is called to handle the move assignment
So the sequence is:
```cpp
// This code:
andy1 = std::move(andy);

// Is effectively doing:
andy1.operator=(static_cast<Person&&>(andy));
//       ^          ^
//       |          std::move does this cast
//       Person's move assignment operator handles this
```
std::move is just a utility that says "treat this object as moveable" - it's the class's move assignment operator that actually does the moving of resources.
Think of:
std::move() as marking something as "okay to take from"
The move assignment operator as doing the actual taking

2. Q: explain static_cast<Person&&>(andy)
2. A: static_cast<Person&&>(andy) is a type conversion that explicitly converts andy from an lvalue Person to an rvalue reference Person&&. Let's break it down: 
```cpp
static_cast<Person&&>(andy)
//        ^    ^     ^
//        |    |     source (lvalue)
//        |    double & means rvalue reference
//        target type for conversion
```
Think of it like:
1. andy is a normal Person object (lvalue - has memory address)
static_cast<Person&&> says "treat this as temporary/moveable data"
The result is an rvalue reference that can be used by move operations
It's similar to this progression:
```cpp
Person andy(25, {"name"});     // andy is lvalue (has address)
static_cast<Person&&>(andy)    // converts to rvalue reference
std::move(andy)               // std::move does same thing internally
```
static_cast is the C++ way of saying "I know what I'm doing, convert this type to that type". In this case:
From: Person (lvalue)
To: Person&& (rvalue reference)
This is exactly what std::move does internally - it's just a convenient wrapper around this type of static_cast.

3. Q: is lvalue pointer and rvalue reference?
3. A: Not exactly. Let me clarify:
lvalue = memory location
```cpp
   int x = 5;      // x is lvalue (has memory address)
   int* ptr = &x;  // ptr is also lvalue (has its own memory address)
```
pointer = holds memory address
```cpp
   int* ptr;    // pointer type (stores address)
   *ptr;        // dereferenced pointer (accesses value at address)
```
reference = alias for memory location
```cpp
   int& ref = x;     // lvalue reference (alias for x)
   int&& rref = 5;   // rvalue reference (reference to temporary)
```
So:
An lvalue is any value with a persistent memory location
A pointer is a variable that stores a memory address
A reference is an alias to an existing variable
Both pointers and references can be lvalues:
```cpp
int* ptr = &x;     // ptr is an lvalue (has address) that stores address
int& ref = x;      // ref is an alias to x
int&& rref = 5;    // rref is an alias to temporary value
```
The key difference:
Pointers store addresses and need dereferencing (*)
References are aliases and act like the original variable
Both can be lvalues because they have their own memory locations

4. Q: describe the difference between a reference and pointer in accessing the value at the memory location 
4. A:  The key difference in accessing values:
```cpp
int x = 42;

// Pointer access:
int* ptr = &x;     // Must use & to get address
cout << *ptr;      // Must use * to get value (42)
*ptr = 10;         // Must use * to modify value

// Reference access:
int& ref = x;      // No & needed for assignment
cout << ref;       // Direct access to value (42)
ref = 10;          // Direct modification of value
```
Reference is like having a nickname for the location
No special syntax to access value
Can't be reassigned to refer to something else
```cpp 
  int y = 5;
  ref = y;   // Modifies x's value, doesn't make ref refer to y
```
Key differences:
Syntax: pointers need * to access value, references don't
Reassignment: pointers can point to different things, references can't
Nullability: pointers can be null, references must refer to something



---

## Const Reference / Copy Constructor 

```cpp
// Copy constructor
Person(const Person &) = delete;
//    ^     ^     ^
//    |     |     single & means lvalue reference
//    |     const means can't modify the source
//    parameter type is Person

// Copy assignment operator
Person &operator=(const Person &) = delete;
```

The const Person & parameter means:
const - Promise not to modify the source object
& - Take a reference (avoid copying)
Together they mean "I want to look at but not modify the original object"
Its like saying:

```cpp 
Person original(25, {"name"});

// This constructor would take a const reference if not deleted:
Person copy(original);  // original is passed as const Person&
                       // can read original but can't modify it
```

Compare with move constructor which takes Person &&:

```cpp
// Move constructor (not deleted)
Person(Person &&person)  // && means rvalue reference
                        // Can modify person because no const
```

The difference:
const Person & - "I'll look but not touch" (copy)
Person && - "I'll take your stuff" (move)
This is similar to TypeScripts:

```ts

// Similar concept
function copyPerson(readonly person: Person)  // Can't modify
function movePerson(person: Person)           // Can modify
```

