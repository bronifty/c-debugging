# Move Constructors

## && Reference 
```ts
// Generic (like C++ template) - type T is a variable
function foo<T>(x: T) { ... }

// Fixed type (like C++ static type) - string is not a variable
function bar(x: string) { ... }
```

```cpp
// Template - T is a variable, && binds to type-variable first
template<typename T>
void foo(T&& x) { ... }

// Fixed type - Person is not a variable, && can only bind to data
void bar(Person&& x) { ... }
```

- The key insight:
When the type is a variable (template/generic), && binds to that type-variable
When the type is fixed (primitive/static), && can only bind to the data
So yes, we could think of fixed types as "primitives" in the sense that they're not variable - they're predefined and immutable at the type level, just like JavaScript's primitive types. The reference (&&) always seeks a variable to bind to, whether that's a type-variable or a data-variable.

## Pointers 

```cpp
int* ptr = new int(5);


// Memory layout:
// ptr         -> [Address1]  // ptr is a memory location storing Address2
// Address1    -> [Address2]  // value stored in ptr (points to the int)
// Address2    -> [5]        // value that ptr points to (*ptr)

&ptr    // gives Address1 (ptr's own location)
ptr     // gives Address2 (location of the int)
*ptr    // gives 5 (value at Address2)
```

## Move Assignment Operator

```cpp 
Person &operator=(Person &&other)
//  ^                    ^
//  returns lvalue ref   takes rvalue ref parameter
{
    // ... operations ...
    return *this;  // *this is an lvalue
}
```

About *this:
this is a pointer to the current object
*this is a dereferenced pointer that gives us the actual object
*this is an lvalue because it refers to the persistent object in memory
We return a reference to this lvalue (Person&)
The return value:

```cpp 
Person &operator=  // Returns lvalue reference
return *this;      // Returns reference to lvalue object
```

```cpp
// Example:
Person a, b;
a = std::move(b);  // b is converted to rvalue                   
// operation returns reference to a (lvalue)
```

The reason *this must be an lvalue is because it refers to the persistent object that continues to exist after the operation. It's not temporary data (rvalue) - it's the actual object in memory that we want to keep using.

