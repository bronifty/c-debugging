# Binary Search Tree

## Example

```c
// ... existing code ...

int main(void) {
    // Create a sample binary search tree
    node *root = malloc(sizeof(node));
    root->number = 5;
    root->left = malloc(sizeof(node));
    root->left->number = 3;
    root->left->left = malloc(sizeof(node));
    root->left->left->number = 1;
    root->left->left->left = NULL;
    root->left->left->right = NULL;
    root->left->right = malloc(sizeof(node));
    root->left->right->number = 4;
    root->left->right->left = NULL;
    root->left->right->right = NULL;
    root->right = malloc(sizeof(node));
    root->right->number = 7;
    root->right->left = malloc(sizeof(node));
    root->right->left->number = 6;
    root->right->left->left = NULL;
    root->right->left->right = NULL;
    root->right->right = malloc(sizeof(node));
    root->right->right->number = 8;
    root->right->right->left = NULL;
    root->right->right->right = NULL;

    // Test the search function
    int numbers_to_search[] = {1, 4, 6, 9};
    int num_searches = sizeof(numbers_to_search) / sizeof(numbers_to_search[0]);

    for (int i = 0; i < num_searches; i++) {
        int number = numbers_to_search[i];
        bool found = search(root, number);
        printf("Number %d is %s in the tree.\n", number, found ? "found" : "not found");
    }

    // Free allocated memory (you should implement a proper free_tree function)
    // This is a simplified version and may cause memory leaks
    free(root->right->right);
    free(root->right->left);
    free(root->right);
    free(root->left->right);
    free(root->left->left);
    free(root->left);
    free(root);

    return 0;
}
```

## Tree Structure Diagram

```
     5
   /   \
  3     7
 / \   / \
1   4 6   8

```
