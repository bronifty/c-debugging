# CPP Primer Notes
## Move Constructors

### && Reference 
```ts
// Generic (like C++ template) - type T is a variable
function foo<T>(x: T) { ... }

// Fixed type (like C++ static type) - string is not a variable
function bar(x: string) { ... }
```

```cpp
// Template - T is a variable, && binds to type-variable first
template<typename T>
void foo(T&& x) { ... }

// Fixed type - Person is not a variable, && can only bind to data
void bar(Person&& x) { ... }
```

- The key insight:
When the type is a variable (template/generic), && binds to that type-variable
When the type is fixed (primitive/static), && can only bind to the data
So yes, we could think of fixed types as "primitives" in the sense that they're not variable - they're predefined and immutable at the type level, just like JavaScript's primitive types. The reference (&&) always seeks a variable to bind to, whether that's a type-variable or a data-variable.

### Pointers 

```cpp
int* ptr = new int(5);


// Memory layout:
// ptr         -> [Address1]  // ptr is a memory location storing Address2
// Address1    -> [Address2]  // value stored in ptr (points to the int)
// Address2    -> [5]        // value that ptr points to (*ptr)

&ptr    // gives Address1 (ptr's own location)
ptr     // gives Address2 (location of the int)
*ptr    // gives 5 (value at Address2)
```

### Move Assignment Operator

```cpp 
Person &operator=(Person &&other)
//  ^                    ^
//  returns lvalue ref   takes rvalue ref parameter
{
    // ... operations ...
    return *this;  // *this is an lvalue
}
```

About *this:
this is a pointer to the current object
*this is a dereferenced pointer that gives us the actual object
*this is an lvalue because it refers to the persistent object in memory
We return a reference to this lvalue (Person&)
The return value:

```cpp 
Person &operator=  // Returns lvalue reference
return *this;      // Returns reference to lvalue object
```

```cpp
// Example:
Person a, b;
a = std::move(b);  // b is converted to rvalue                   
// operation returns reference to a (lvalue)
```

The reason *this must be an lvalue is because it refers to the persistent object that continues to exist after the operation. It's not temporary data (rvalue) - it's the actual object in memory that we want to keep using.

#### LLM Q&A
1. Q: in C++ when std::move(Person&&) is called, that is a function implemented by the Person class, and specifically in the move assignement operator Person &operator=(Person &&other) {...}?
1. A: Not exactly. Let me clarify:
std::move() is a standard library function, not a member of the Person class
```cpp 
   // std::move just casts its argument to an rvalue reference
   std::move(andy);  // Converts andy to Person&&
```
When you do:
```cpp 
   Person andy1;
   andy1 = std::move(andy);  // Two steps happen:
```
What actually happens is:
First, std::move(andy) converts andy to an rvalue reference (Person&&)
Then, Person::operator=(Person&&) is called to handle the move assignment
So the sequence is:
```cpp
// This code:
andy1 = std::move(andy);

// Is effectively doing:
andy1.operator=(static_cast<Person&&>(andy));
//       ^          ^
//       |          std::move does this cast
//       Person's move assignment operator handles this
```
std::move is just a utility that says "treat this object as moveable" - it's the class's move assignment operator that actually does the moving of resources.
Think of:
std::move() as marking something as "okay to take from"
The move assignment operator as doing the actual taking

2. Q: explain static_cast<Person&&>(andy)
2. A: static_cast<Person&&>(andy) is a type conversion that explicitly converts andy from an lvalue Person to an rvalue reference Person&&. Let's break it down: 
```cpp
static_cast<Person&&>(andy)
//        ^    ^     ^
//        |    |     source (lvalue)
//        |    double & means rvalue reference
//        target type for conversion
```
Think of it like:
1. andy is a normal Person object (lvalue - has memory address)
static_cast<Person&&> says "treat this as temporary/moveable data"
The result is an rvalue reference that can be used by move operations
It's similar to this progression:
```cpp
Person andy(25, {"name"});     // andy is lvalue (has address)
static_cast<Person&&>(andy)    // converts to rvalue reference
std::move(andy)               // std::move does same thing internally
```
static_cast is the C++ way of saying "I know what I'm doing, convert this type to that type". In this case:
From: Person (lvalue)
To: Person&& (rvalue reference)
This is exactly what std::move does internally - it's just a convenient wrapper around this type of static_cast.

3. Q: is lvalue pointer and rvalue reference?
3. A: Not exactly. Let me clarify:
lvalue = memory location
```cpp
   int x = 5;      // x is lvalue (has memory address)
   int* ptr = &x;  // ptr is also lvalue (has its own memory address)
```
pointer = holds memory address
```cpp
   int* ptr;    // pointer type (stores address)
   *ptr;        // dereferenced pointer (accesses value at address)
```
reference = alias for memory location
```cpp
   int& ref = x;     // lvalue reference (alias for x)
   int&& rref = 5;   // rvalue reference (reference to temporary)
```
So:
An lvalue is any value with a persistent memory location
A pointer is a variable that stores a memory address
A reference is an alias to an existing variable
Both pointers and references can be lvalues:
```cpp
int* ptr = &x;     // ptr is an lvalue (has address) that stores address
int& ref = x;      // ref is an alias to x
int&& rref = 5;    // rref is an alias to temporary value
```
The key difference:
Pointers store addresses and need dereferencing (*)
References are aliases and act like the original variable
Both can be lvalues because they have their own memory locations

4. Q: describe the difference between a reference and pointer in accessing the value at the memory location 
4. A:  The key difference in accessing values:
```cpp
int x = 42;

// Pointer access:
int* ptr = &x;     // Must use & to get address
cout << *ptr;      // Must use * to get value (42)
*ptr = 10;         // Must use * to modify value

// Reference access:
int& ref = x;      // No & needed for assignment
cout << ref;       // Direct access to value (42)
ref = 10;          // Direct modification of value
```
Reference is like having a nickname for the location
No special syntax to access value
Can't be reassigned to refer to something else
```cpp 
  int y = 5;
  ref = y;   // Modifies x's value, doesn't make ref refer to y
```
Key differences:
Syntax: pointers need * to access value, references don't
Reassignment: pointers can point to different things, references can't
Nullability: pointers can be null, references must refer to something

5. Q: explain the meaning of "&operator=" in the move assignment operator syntax. does & refer to a memory address?
5. A: In Person &operator=, the & is indicating that this function returns a reference to a Person, not a memory address. Let's break it down:
```cpp 
Person &operator=(Person &&other)
//     ^
//     returns a reference to Person (not a copy)
```
This syntax means:
operator= is the function name (overloading the = operator)
Person & means it returns a reference to the current Person object
This enables chaining of assignments:
```cpp 
Person a, b, c;
a = b = c;  // Possible because = returns reference
// equivalent to:
// b.operator=(c)   returns reference to b
// a.operator=(b)   returns reference to a
```
Without the & (returning by reference):
```cpp
Person operator=(Person &&other)  // Returns by value (copy)
```
This would:
Create a copy of the object
Be less efficient
Not allow chaining
The & here is different from pointer syntax:
& in return type = "return a reference"
& with variable = "get address of"
& in parameter = "lvalue reference"
&& in parameter = "rvalue reference"

6. Q: help me with this chaining logic. you said a.operator=(b) returns a reference to a? i thought a would be assigned to the value of the reference b?
6 A: Let me clarify the chaining with a = b = c:
```cpp 
// This expression:
a = b = c;

// Is evaluated right to left:
1. b = c        // First, b.operator=(c) happens
                // - Moves c's contents to b
                // - Returns reference to b

2. a = (b)      // Then a.operator=(b) happens
                // - Moves b's contents to a
                // - Returns reference to a
```
Let's see it with the actual move assignment operator:
```cpp 
Person& operator=(Person&& other) {  // Takes rvalue reference
    // Move other's contents to this object
    age_ = other.age_;
    nicknames_ = std::move(other.nicknames_);
    valid_ = true;
    other.valid_ = false;

    return *this;   // Returns reference to current object
}
```
So when you do a = b = c:
b = c:
Moves c's contents into b
Returns reference to b (now containing c's data)
a = b:
Moves b's contents (originally from c) into a
Returns reference to a
You're right that values are being moved, but the operator returns a reference to allow chaining. The reference isn't what's being assigned - it's just what's being returned to enable the next assignment.

7. Q: return *this;   // Returns reference to current object can we also return &this; ? 
7. A: No, we cannot return &this because:
this is already a pointer to the current object
&this would be a pointer to a pointer, which doesn't match our return type
Here's what each would mean:
```cpp 
this      // Pointer to current object
*this     // The current object itself (dereferenced)
&this     // Address of the pointer (wrong!)

Person& operator=(Person&& other) {
    // ...
    return *this;   // Correct: returns reference to object
    return &this;   // Wrong: would return pointer to pointer
}
```
Think of it like: 
```cpp 
Person obj;
this         -> 0x123           // Memory address of obj
*this        -> Person{...}     // The actual object
&this        -> 0x456          // Address of the pointer (wrong!)

// Return type is Person& (reference to Person)
// *this gives us the Person object we can reference
// &this would give us pointer to pointer (Person**)
```
Remember:
When returning a reference (Person&), we need the object itself (*this)
& of a pointer gives us a pointer-to-pointer, which isn't what we want
*this dereferences the pointer to get the actual object we can reference

8. Q: add pointer syntax to complete this list: & in return type = "return a reference"
& with variable = "get address of"
& in parameter = "lvalue reference"
&& in parameter = "rvalue reference"
8. A: Here's the complete list of & and * syntax in C++:
```cpp 
// & Syntax:
& in return type    = "return a reference"          // Person&
& with variable    = "get address of"              // &myVar
& in parameter     = "lvalue reference"            // void foo(Person& p)
&& in parameter    = "rvalue reference"            // void foo(Person&& p)

// * Syntax:
* in declaration   = "declare a pointer"           // Person* ptr
* with variable    = "dereference pointer"         // *ptr
* in return type   = "return a pointer"            // Person* foo()

// Combined examples:
Person* ptr = &person;     // * declares pointer, & gets address
Person& ref = *ptr;        // & declares reference, * dereferences
*ptr = std::move(person);  // * dereferences, then assigns
```
Think of:
& as either "reference" or "address of"
* as either "pointer" or "value at address"
The meaning depends on where it appears in the code (declaration vs usage).

9. Q: is it accurate to say * is a pointer to a memory address or its value and & is the memory address?
9. A: Yes, that's a good way to think about it! Let me illustrate:
```cpp 
int x = 42;        // Regular variable

int* ptr = &x;     // ptr stores memory address of x
                   // * = pointer that can hold an address
                   // & = get the address

// Using them:
*ptr               // Follow pointer to get value (42)
&x                 // Get address of x (e.g., 0x123)

// Visualized:
x:    [42]        // at address 0x123
ptr:  [0x123]     // points to x's address
*ptr: [42]        // value at address ptr points to
&x:   0x123       // address of x
```
So:
* means "follow this address to its value" or "pointer type"
& means "get the address of" or "reference type"
Think of:
* as "what's at this address?"
& as "what's the address?"
The only exception is when they're used in type declarations (like int& for references), but for general usage with variables, this mental model works well!

10. Q: please elaborate on the exception case  when they're used in type declarations (like int& for references)
10. A: In type declarations, & and && have special meanings that differ from their usage with variables. Let me show you:
```cpp 
// Type Declarations (in parameters or return types):
void foo(int& x)      // & declares lvalue reference type
void bar(int&& x)     // && declares rvalue reference type
int& getValue()       // & declares reference return type

// Variable Usage:
int x = 42;
int* ptr = &x;        // & gets address
*ptr = 43;            // * dereferences

// Compare these declarations:
int* ptr;             // Pointer: can store an address
int& ref = x;         // Reference: must be initialized, is an alias
int&& rref = 5;       // Rvalue reference: can bind to temporary
```
---

### Const Reference / Copy Constructor 

```cpp
// Copy constructor
Person(const Person &) = delete;
//    ^     ^     ^
//    |     |     single & means lvalue reference
//    |     const means can't modify the source
//    parameter type is Person

// Copy assignment operator
Person &operator=(const Person &) = delete;
```

The const Person & parameter means:
const - Promise not to modify the source object
& - Take a reference (avoid copying)
Together they mean "I want to look at but not modify the original object"
Its like saying:

```cpp 
Person original(25, {"name"});

// This constructor would take a const reference if not deleted:
Person copy(original);  // original is passed as const Person&
                       // can read original but can't modify it
```

Compare with move constructor which takes Person &&:

```cpp
// Move constructor (not deleted)
Person(Person &&person)  // && means rvalue reference
                        // Can modify person because no const
```

The difference:
const Person & - "I'll look but not touch" (copy)
Person && - "I'll take your stuff" (move)
This is similar to TypeScripts:

```ts

// Similar concept
function copyPerson(readonly person: Person)  // Can't modify
function movePerson(person: Person)           // Can modify
```

## Move Semantics

1. Q: it looks like std::vector<int> &&rvalue_stealing_ints = std::move(stealing_ints); move operation converted the lvalue to an rvalue and assigned it to rvalue_stealing_ints as a reference to the lvalue, but did not change ownership. in this way, std::move acted as a cast, essentially of lvalue to rvalue type if you could call it that
1. A: Yes, exactly! std::move is just a cast - it doesn't actually move anything. Let me break this down:
```cpp 
std::vector<int> &&rvalue_stealing_ints = std::move(stealing_ints);
//                                       ^
//                                       Just casts stealing_ints to an rvalue reference
```
What's happening:
std::move(stealing_ints) is equivalent to static_cast<std::vector<int>&&>(stealing_ints)
This just tells the compiler "treat this lvalue as an rvalue"
No actual moving happens until this rvalue reference is used in a move operation
For example:
```cpp 
// Just casting - no move yet
std::vector<int> &&rref = std::move(vec);  

// Actual move happens here
std::vector<int> new_vec = std::move(vec);  // Move constructor called
// or
other_vec = std::move(vec);                 // Move assignment called
```
Think of std::move as:
Not a move operation
Just a type conversion from lvalue to rvalue reference
Gives permission to move ("this can be stolen from")
Actual moving happens in move constructors/assignment operators
It's like putting a "free to take" sign on something - the sign doesn't move anything, it just indicates that moving is allowed!

## Wrapper Class
1. Q: does *parameter mean pointer? why not use a reference? (RawResourceHandle* rawHandle_) 
1. A: Yes, RawResourceHandle* rawHandle_ is a pointer parameter. The choice between pointer and reference often depends on ownership semantics:
```cpp 
class ManagedResourceHandle {
public:
    // Pointer indicates ownership - this class will delete the resource
    ManagedResourceHandle(RawResourceHandle* rawHandle_) 
        : rawHandle(rawHandle_) {}
    ~ManagedResourceHandle() { delete rawHandle; }

private:
    RawResourceHandle* rawHandle;  // Owns the resource
};

// vs

class ResourceUser {
public:
    // Reference indicates "I'm just using it, not owning it"
    ResourceUser(RawResourceHandle& resource_) 
        : resource(resource_) {}
    // No destructor needed - we don't own the resource

private:
    RawResourceHandle& resource;  // Just refers to resource
};
```
Key differences:
Ownership:
Pointer (*): Can indicate ownership (responsibility to delete)
Reference (&): Never indicates ownership
Nullability:
Pointer: Can be null
Valid
- Reference: Must refer to valid object
initialized
Lifetime:
Pointer: Object might outlive pointer
Reference: Referenced object must outlive reference
In this case, pointer is used because:
The class takes ownership of the resource
It needs to delete the resource in destructor
Might need to check for null
This is a common pattern in resource management classes.

## Iterator 
// The main components of a C++ iterator are its main two operators. The
// dereference operator (*) on an iterator should return the value of the
// element at the current position of the iterator. The ++ (postfix increment)
// operator should increment the iterator's position by 1.

1. Q: explain this syntax Node* head_{nullptr};
1. A: This line Node* head_{nullptr}; is using C++ in-class member initialization syntax. Let's break it down:
Node* - This declares a pointer to a Node object
head_ - This is the name of the member variable
{nullptr} - This is the in-class initializer using uniform initialization syntax (with curly braces)
This is equivalent to these older ways of writing it:
```cpp 
// Old style in header:
Node* head_;  // Declaration only
// Then in constructor:
DLL() : head_(nullptr) {}  // Initialize in constructor initializer list

// Or even older style:
Node* head_;  // Declaration
DLL() {       // Initialize in constructor body
    head_ = nullptr;
}
```
The modern in-class initialization syntax Node* head_{nullptr}; has several advantages:
It's more concise
The initialization is visible right at the point of declaration
It ensures the member is initialized even if you forget to initialize it in a constructor
It reduces the chance of errors in multiple constructors since the default initialization is specified once
This syntax was introduced in C++11 and is now considered a best practice when you want to give member variables default values.

2. Q: please help me understand the logic of this function 
2. A: 
```cpp 
void InsertAtHead(int val) {
    // 1. Create a new node with the given value
    Node *new_node = new Node(val);
    
    // 2. Make the new node's next pointer point to the current head
    new_node->next_ = head_;

    // 3. If the list is not empty (head_ exists)
    if (head_ != nullptr) {
        // Make the current head's prev pointer point back to the new node
        head_->prev_ = new_node;
    }

    // 4. Make the new node the new head of the list
    head_ = new_node;
    
    // 5. Increment the size counter
    size_ += 1;
}
```
Let's visualize this with an example:
Initial state (list has one node with value 5):
```
head_ → [5] → nullptr
```
Calling InsertAtHead(3):
Create new node: [3]
Set new_node->next_ to current head:
```
[3] → [5] → nullptr
```
- Set old head's prev_ to point to new node:
```
[3] ⟷ [5] → nullptr
```
- Update head_ to point to new node:
```
head_ → [3] ⟷ [5] → nullptr
```
The function handles two cases:
Empty list (head_ is nullptr): Simply makes the new node the head
Non-empty list: Maintains doubly-linked connections between nodes
This is how the list grows from the front, maintaining both forward (next_) and backward (prev_) links between nodes.

3. Q: would it be accurate to state that this DLL class is inserting nodes at the beginning (to the left) of the list; further, would it be consistent to refer to next_ as right and prev_ as left?
3. A: Yes, you're absolutely correct on both points!
The InsertAtHead function is indeed adding new nodes at the beginning (left side) of the list. Each new insertion pushes existing nodes further to the right. For example, if we insert 1, 2, 3 in that order: 
```
Insert 1:
head_ → [1] → nullptr

Insert 2:
head_ → [2] ⟷ [1] → nullptr

Insert 3:
head_ → [3] ⟷ [2] ⟷ [1] → nullptr
```
It is completely consistent to think of:
next_ as pointing to the right
prev_ as pointing to the left
This mental model aligns with how we typically visualize linked lists horizontally, with:
The head being on the left
Each next_ pointer moving rightward
Each prev_ pointer moving leftward
nullptr at the rightmost end
This is why in the main function's output, when we iterate through the list:
```
1 2 3 4 5 6
```
4. Q: a good reason why a reference, directly using the address of an object with &, cannot have ownership of the object, is because an object (whose address is referenced) cannot delete itself, whereas a pointer, which is a distinct memory slot with a value of a reference through a memory address to an object's data (like a k:v entry, with address being k, data v), can. for instance, a pointer is assigned to an object reference, deletes the reference and is then reassigned to another in order to delete that as well in the class' RAII destructor
4. A: Yes, exactly! Your understanding is spot-on. Let me elaborate on why pointers are necessary for ownership and memory management:
In the destructor code you highlighted:
```cpp 
~DLL() {
    Node *current = head_;        // Pointer can be reassigned
    while(current != nullptr) {
        Node *next = current->next_;  // Save next pointer before deletion
        delete current;               // Delete current object
        current = next;              // Move to saved next pointer
    }
    head_ = nullptr;
}
```
If we tried to use instead: 
```cpp 
// This wouldn't work!
Node& current = head_;  // References can't be reassigned
delete &current;        // After this, current would be a dangling reference
current = next;         // Can't reassign references!
```
Key differences that make pointers necessary for ownership:
Reassignment:
Pointers can be reassigned: ptr = nullptr or ptr = new_value
References are bound once and can't be reseated: ref = other modifies the referenced value, not the reference itself
Null state:
Pointers can be null: ptr = nullptr
Valid
- Reference: Must refer to valid object
initialized
Memory management:
Pointers can delete their pointee: delete ptr
References can't delete their referent: delete &ref would be dangerous as the reference would still exist
This is why smart pointers (like unique_ptr and shared_ptr) are built on raw pointers, not references - they need these pointer capabilities for proper memory management.

## Vectors.cpp 
1. Q: why isn't elem an address rather than a value since it's being referred to with & ? please append your answer including this question to notes.mdx
A: ## Range-Based For Loops and References

In the code:
```cpp
void print_int_vector(const std::vector<int> &vec) {
  for (const int &elem : vec) {
    std::cout << elem << " ";
  }
  std::cout << "\n";
}
```

The `const int &elem` syntax might seem confusing at first. Here's what's happening:

1. The range-based for loop automatically provides references to each element
2. `elem` is not an address - it's a reference that acts as an alias to the actual element
3. When you use the reference, you're working directly with the element's value

Compare these:
```cpp
// Using reference in range-based for
for (const int &elem : vec) {
    cout << elem;     // elem is an alias, prints value directly
}

// Using pointer (if we had array of pointers)
for (int* ptr : ptr_vec) {
    cout << *ptr;     // Need * to dereference pointer
}
```

Key points:
- & in the loop declares elem as a reference (alias)
- You don't need & to get elem's value because it's already an alias
- Using references avoids copying values in the loop
- const prevents modification of the original elements

Think of it like:
```cpp
vector<int> vec = {1, 2, 3};

// This loop:
for (const int &elem : vec) { ... }

// Is conceptually similar to:
for (int i = 0; i < vec.size(); i++) {
    const int &elem = vec[i];  // Reference to each element
    // ... use elem ...
}
```

The & in the loop syntax creates a reference variable, rather than getting an address like & does in other contexts.

Q: what is size_t?

## Common Types

### size_t
`size_t` is an unsigned integer type that is used to represent sizes and counts. It's particularly important when working with container sizes and array indices.

```cpp
// Using size_t for array indexing
for (size_t i = 0; i < vector.size(); ++i) {
    // size_t is guaranteed to be big enough for any array index
}
```

Key points about size_t:
- Unsigned integer type (can't be negative)
- Guaranteed to be large enough to contain the size of any object
- Usually 32 bits on 32-bit systems, 64 bits on 64-bit systems
- Preferred type for array indices and sizes
- Returned by sizeof operator and container size() methods

Why use size_t instead of int:
```cpp
vector<int> vec(1000000000);  // Large vector

// Bad: int might overflow on some systems
for (int i = 0; i < vec.size(); i++) { }

// Good: size_t guaranteed to handle any valid size
for (size_t i = 0; i < vec.size(); i++) { }
```

Common places you'll see size_t:
- Container sizes: vector.size() returns size_t
- Array indexing: array[size_t index]
- Memory operations: sizeof returns size_t
- String lengths: string::length() returns size_t